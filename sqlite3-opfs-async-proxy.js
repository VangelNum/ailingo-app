"use strict";const wPost=(e,...t)=>postMessage({type:e,payload:t});const installAsyncProxy=function(e){const t=function(...e){throw new Error(e.join(" "))};if(globalThis.window===globalThis){t("This code cannot run from the main thread.","Load it as a Worker from a separate Worker.")}else if(!navigator?.storage?.getDirectory){t("This API requires navigator.storage.getDirectory.")}const n=Object.create(null);n.verbose=1;const s={0:console.error.bind(console),1:console.warn.bind(console),2:console.log.bind(console)};const o=(e,...t)=>{if(n.verbose>e)s[e]("OPFS asyncer:",...t)};const a=(...e)=>o(2,...e);const i=(...e)=>o(1,...e);const c=(...e)=>o(0,...e);const r=Object.create(null);r.reset=()=>{let e;const t=e=>e.count=e.time=e.wait=0;for(e in n.opIds){t(r[e]=Object.create(null))}let s=r.s11n=Object.create(null);s=s.serialize=Object.create(null);s.count=s.time=0;s=r.s11n.deserialize=Object.create(null);s.count=s.time=0};r.dump=()=>{let e,t=0,s=0,o=0;for(e in n.opIds){const n=r[e];t+=n.count;s+=n.time;o+=n.wait;n.avgTime=n.count&&n.time?n.time/n.count:0}console.log(globalThis?.location?.href,"metrics for",globalThis?.location?.href,":\n",r,"\nTotal of",t,"op(s) for",s,"ms","approx",o,"ms spent waiting on OPFS APIs.");console.log("Serialization metrics:",r.s11n)};const l=Object.create(null);const f=new Set;const d=function(e,t){const n=new URL(e,"file://irrelevant").pathname;return t?n.split("/").filter((e=>!!e)):n};const u=async function e(t,s=false){const o=d(t,true);const a=o.pop();let i=n.rootDir;for(const e of o){if(e){i=await i.getDirectoryHandle(e,{create:!!s})}}return[i,a]};const y=async e=>{if(e.syncHandle){a("Closing sync handle for",e.filenameAbs);const t=e.syncHandle;delete e.syncHandle;delete e.xLock;f.delete(e.fid);return t.close()}};const p=async e=>{try{await y(e)}catch(t){i("closeSyncHandleNoThrow() ignoring:",t,e)}};const w=async()=>{if(f.size){for(const e of f){const t=l[e];await p(t);a("Auto-unlocked",e,t.filenameAbs)}}};const b=async e=>{if(e.releaseImplicitLocks&&f.has(e.fid)){return p(e)}};class m extends Error{constructor(e,...t){super([...t,": "+e.name+":",e.message].join(" "),{cause:e});this.name="GetSyncHandleError"}}m.convertRc=(e,t)=>{if(1){return e instanceof m&&(e.cause.name==="NoModificationAllowedError"||e.cause.name==="DOMException"&&0===e.cause.message.indexOf("Access Handles cannot"))?n.sq3Codes.SQLITE_BUSY:t}else{return t}};const O=async(e,t)=>{if(!e.syncHandle){const s=performance.now();a("Acquiring sync handle for",e.filenameAbs);const o=6,c=n.asyncIdleWaitTime*2;let r=1,l=c;for(;true;l=c*++r){try{e.syncHandle=await e.fileHandle.createSyncAccessHandle();break}catch(s){if(r===o){throw new m(s,"Error getting sync handle for",t+"().",o,"attempts failed.",e.filenameAbs)}i("Error getting sync handle for",t+"(). Waiting",l,"ms and trying again.",e.filenameAbs,s);Atomics.wait(n.sabOPView,n.opIds.retry,0,l)}}a("Got",t+"() sync handle for",e.filenameAbs,"in",performance.now()-s,"ms");if(!e.xLock){f.add(e.fid);a("Acquired implicit lock for",t+"()",e.fid,e.filenameAbs)}}return e.syncHandle};const E=(e,t)=>{a(e+"() => notify(",t,")");Atomics.store(n.sabOPView,n.opIds.rc,t);Atomics.notify(n.sabOPView,n.opIds.rc)};const g=function(e,n){if(n.readOnly)t(e+"(): File is read-only: "+n.filenameAbs)};const h=Object.create(null);h.op=undefined;h.start=undefined;const x=e=>{h.start=performance.now();h.op=e;++r[e].count};const I=()=>r[h.op].time+=performance.now()-h.start;const S=Object.create(null);S.op=undefined;S.start=undefined;const T=e=>{S.start=performance.now();S.op=e};const A=()=>r[S.op].wait+=performance.now()-S.start;let L=false;const R={"opfs-async-metrics":async()=>{x("opfs-async-metrics");r.dump();E("opfs-async-metrics",0);I()},"opfs-async-shutdown":async()=>{L=true;E("opfs-async-shutdown",0)},mkdir:async e=>{x("mkdir");let t=0;T("mkdir");try{await u(e+"/filepart",true)}catch(e){n.s11n.storeException(2,e);t=n.sq3Codes.SQLITE_IOERR}finally{A()}E("mkdir",t);I()},xAccess:async e=>{x("xAccess");let t=0;T("xAccess");try{const[t,n]=await u(e);await t.getFileHandle(n)}catch(e){n.s11n.storeException(2,e);t=n.sq3Codes.SQLITE_IOERR}finally{A()}E("xAccess",t);I()},xClose:async function(e){const t="xClose";x(t);f.delete(e);const s=l[e];let o=0;T(t);if(s){delete l[e];await y(s);if(s.deleteOnClose){try{await s.dirHandle.removeEntry(s.filenamePart)}catch(e){i("Ignoring dirHandle.removeEntry() failure of",s,e)}}}else{n.s11n.serialize();o=n.sq3Codes.SQLITE_NOTFOUND}A();E(t,o);I()},xDelete:async function(...e){x("xDelete");const t=await R.xDeleteNoWait(...e);E("xDelete",t);I()},xDeleteNoWait:async function(e,t=0,s=false){let o=0;T("xDelete");try{while(e){const[n,o]=await u(e,false);if(!o)break;await n.removeEntry(o,{recursive:s});if(4660!==t)break;s=false;e=d(e,true);e.pop();e=e.join("/")}}catch(e){n.s11n.storeException(2,e);o=n.sq3Codes.SQLITE_IOERR_DELETE}A();return o},xFileSize:async function(e){x("xFileSize");const t=l[e];let s=0;T("xFileSize");try{const e=await(await O(t,"xFileSize")).getSize();n.s11n.serialize(Number(e))}catch(e){n.s11n.storeException(1,e);s=m.convertRc(e,n.sq3Codes.SQLITE_IOERR)}await b(t);A();E("xFileSize",s);I()},xLock:async function(e,t){x("xLock");const s=l[e];let o=0;const a=s.xLock;s.xLock=t;if(!s.syncHandle){T("xLock");try{await O(s,"xLock");f.delete(e)}catch(e){n.s11n.storeException(1,e);o=m.convertRc(e,n.sq3Codes.SQLITE_IOERR_LOCK);s.xLock=a}A()}E("xLock",o);I()},xOpen:async function(e,t,s,o){const a="xOpen";x(a);const i=n.sq3Codes.SQLITE_OPEN_CREATE&s;T("xOpen");try{let c,r;try{[c,r]=await u(t,!!i)}catch(e){n.s11n.storeException(1,e);E(a,n.sq3Codes.SQLITE_NOTFOUND);I();A();return}const f=await c.getFileHandle(r,{create:i});A();const d=Object.assign(Object.create(null),{fid:e,filenameAbs:t,filenamePart:r,dirHandle:c,fileHandle:f,sabView:n.sabFileBufView,readOnly:i?false:n.sq3Codes.SQLITE_OPEN_READONLY&s,deleteOnClose:!!(n.sq3Codes.SQLITE_OPEN_DELETEONCLOSE&s)});d.releaseImplicitLocks=o&n.opfsFlags.OPFS_UNLOCK_ASAP||n.opfsFlags.defaultUnlockAsap;if(0&&0===(s&n.sq3Codes.SQLITE_OPEN_MAIN_DB)){d.xLock="xOpen";await O(d,"xOpen")}l[e]=d;E(a,0)}catch(e){A();c(a,e);n.s11n.storeException(1,e);E(a,n.sq3Codes.SQLITE_IOERR)}I()},xRead:async function(e,t,s){x("xRead");let o=0,a;const i=l[e];try{T("xRead");a=(await O(i,"xRead")).read(i.sabView.subarray(0,t),{at:Number(s)});A();if(a<t){i.sabView.fill(0,a,t);o=n.sq3Codes.SQLITE_IOERR_SHORT_READ}}catch(e){if(undefined===a)A();c("xRead() failed",e,i);n.s11n.storeException(1,e);o=m.convertRc(e,n.sq3Codes.SQLITE_IOERR_READ)}await b(i);E("xRead",o);I()},xSync:async function(e,t){x("xSync");const s=l[e];let o=0;if(!s.readOnly&&s.syncHandle){try{T("xSync");await s.syncHandle.flush()}catch(e){n.s11n.storeException(2,e);o=n.sq3Codes.SQLITE_IOERR_FSYNC}A()}E("xSync",o);I()},xTruncate:async function(e,t){x("xTruncate");let s=0;const o=l[e];T("xTruncate");try{g("xTruncate",o);await(await O(o,"xTruncate")).truncate(t)}catch(e){c("xTruncate():",e,o);n.s11n.storeException(2,e);s=m.convertRc(e,n.sq3Codes.SQLITE_IOERR_TRUNCATE)}await b(o);A();E("xTruncate",s);I()},xUnlock:async function(e,t){x("xUnlock");let s=0;const o=l[e];if(n.sq3Codes.SQLITE_LOCK_NONE===t&&o.syncHandle){T("xUnlock");try{await y(o)}catch(e){n.s11n.storeException(1,e);s=n.sq3Codes.SQLITE_IOERR_UNLOCK}A()}E("xUnlock",s);I()},xWrite:async function(e,t,s){x("xWrite");let o;const a=l[e];T("xWrite");try{g("xWrite",a);o=t===(await O(a,"xWrite")).write(a.sabView.subarray(0,t),{at:Number(s)})?0:n.sq3Codes.SQLITE_IOERR_WRITE}catch(e){c("xWrite():",e,a);n.s11n.storeException(1,e);o=m.convertRc(e,n.sq3Codes.SQLITE_IOERR_WRITE)}await b(a);A();E("xWrite",o);I()}};const _=()=>{if(n.s11n)return n.s11n;const e=new TextDecoder,s=new TextEncoder("utf-8"),o=new Uint8Array(n.sabIO,n.sabS11nOffset,n.sabS11nSize),a=new DataView(n.sabIO,n.sabS11nOffset,n.sabS11nSize);n.s11n=Object.create(null);const i=Object.create(null);i.number={id:1,size:8,getter:"getFloat64",setter:"setFloat64"};i.bigint={id:2,size:8,getter:"getBigInt64",setter:"setBigInt64"};i.boolean={id:3,size:4,getter:"getInt32",setter:"setInt32"};i.string={id:4};const c=e=>i[typeof e]||t("Maintenance required: this value type cannot be serialized.",e);const l=e=>{switch(e){case i.number.id:return i.number;case i.bigint.id:return i.bigint;case i.boolean.id:return i.boolean;case i.string.id:return i.string;default:t("Invalid type ID:",e)}};n.s11n.deserialize=function(t=false){++r.s11n.deserialize.count;const s=performance.now();const i=o[0];const c=i?[]:null;if(i){const t=[];let s=1,r,f,d;for(r=0;r<i;++r,++s){t.push(l(o[s]))}for(r=0;r<i;++r){const i=t[r];if(i.getter){d=a[i.getter](s,n.littleEndian);s+=i.size}else{f=a.getInt32(s,n.littleEndian);s+=4;d=e.decode(o.slice(s,s+f));s+=f}c.push(d)}}if(t)o[0]=0;r.s11n.deserialize.time+=performance.now()-s;return c};n.s11n.serialize=function(...e){const t=performance.now();++r.s11n.serialize.count;if(e.length){const t=[];let i=0,r=1;o[0]=e.length&255;for(;i<e.length;++i,++r){t.push(c(e[i]));o[r]=t[i].id}for(i=0;i<e.length;++i){const c=t[i];if(c.setter){a[c.setter](r,e[i],n.littleEndian);r+=c.size}else{const t=s.encode(e[i]);a.setInt32(r,t.byteLength,n.littleEndian);r+=4;o.set(t,r);r+=t.byteLength}}}else{o[0]=0}r.s11n.serialize.time+=performance.now()-t};n.s11n.storeException=n.asyncS11nExceptions?(e,t)=>{if(e<=n.asyncS11nExceptions){n.s11n.serialize([t.name,": ",t.message].join(""))}}:()=>{};return n.s11n};const C=async function e(){const s=Object.create(null);for(let e of Object.keys(n.opIds)){const t=R[e];if(!t)continue;const o=Object.create(null);s[n.opIds[e]]=o;o.key=e;o.f=t}while(!L){try{if("not-equal"!==Atomics.wait(n.sabOPView,n.opIds.whichOp,0,n.asyncIdleWaitTime)){await w();continue}const e=Atomics.load(n.sabOPView,n.opIds.whichOp);Atomics.store(n.sabOPView,n.opIds.whichOp,0);const o=s[e]??t("No waitLoop handler for whichOp #",e);const a=n.s11n.deserialize(true)||[];if(o.f)await o.f(...a);else c("Missing callback for opId",e)}catch(e){c("in waitLoop():",e)}}};navigator.storage.getDirectory().then((function(e){n.rootDir=e;globalThis.onmessage=function({data:e}){switch(e.type){case"opfs-async-init":{const s=e.args;for(const e in s)n[e]=s[e];n.verbose=s.verbose??1;n.sabOPView=new Int32Array(n.sabOP);n.sabFileBufView=new Uint8Array(n.sabIO,0,n.fileBufferSize);n.sabS11nView=new Uint8Array(n.sabIO,n.sabS11nOffset,n.sabS11nSize);Object.keys(R).forEach((e=>{if(!Number.isFinite(n.opIds[e])){t("Maintenance required: missing state.opIds[",e,"]")}}));_();r.reset();a("init state",n);wPost("opfs-async-inited");C();break}case"opfs-async-restart":if(L){i("Restarting after opfs-async-shutdown. Might or might not work.");L=false;C()}break;case"opfs-async-metrics":r.dump();break}};wPost("opfs-async-loaded")})).catch((e=>c("error initializing OPFS asyncer:",e)))};if(!globalThis.SharedArrayBuffer){wPost("opfs-unavailable","Missing SharedArrayBuffer API.","The server must emit the COOP/COEP response headers to enable that.")}else if(!globalThis.Atomics){wPost("opfs-unavailable","Missing Atomics API.","The server must emit the COOP/COEP response headers to enable that.")}else if(!globalThis.FileSystemHandle||!globalThis.FileSystemDirectoryHandle||!globalThis.FileSystemFileHandle||!globalThis.FileSystemFileHandle.prototype.createSyncAccessHandle||!navigator?.storage?.getDirectory){wPost("opfs-unavailable","Missing required OPFS APIs.")}else{installAsyncProxy(self)}